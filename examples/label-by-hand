#!/usr/bin/env lua5.1
-- -*- mode: lua -*-

local pname = 'osbf3'

local function submod(x) return require (pname .. '.' .. x) end

local osbf = require (pname)
local util = submod 'util'
local commands = submod 'commands'
local msg = submod 'msg'
local cfg = submod 'cfg'
local options = submod 'options'
local core = submod 'core'

function os.exists(file)
  local f, msg = io.open(file, 'r')
  if f then
    f:close()
    return true
  else
    return false, msg
  end
end

util.progname = arg[0] or util.progname

local corpora = os.getenv 'HOME' .. '/osbf/corpora/cooked'
local function add_to_corpus (file, class)
  local function next_filename(dir)
    assert(os.exists(dir))
    local function fname(n) return string.format('%s/%03d', dir, n) end
    local function exists(n) return os.exists(fname(n)) end
    local lo, hi = 0, 1
    if not exists(lo) then return fname(lo)
    else
      while exists(hi) do hi = hi * 2 end
      -- now: not exists(lo) and exists(hi) and hi > lo
      while hi - lo > 1 do
        local mid = math.floor ((lo + hi) / 2)
        if exists(mid) then lo = mid else hi = mid end
      end
      assert (exists(lo) and not exists(hi) and lo + 1 == hi)
      return fname(hi)
    end
  end
  local f = next_filename(corpora .. '/' .. class)
  os.execute(string.format('mv -v %s %s', os.quote(file), os.quote(f)))
end

options.register { long = 'trace', usage = ' # stack trace on error',
                   help = [[
  --trace
      Don't recover from errors; give a stack trace instead
]] }

options.register { long = 'force', usage = ' # force labelling' }
options.register { long = 'corpora', type = options.std.dir }
options.register { long = 'nocorpora' }


local ok, options, args = pcall(osbf.options.parse, arg)
if not ok then
  util.die(options, '\n')
end
if options.trace then
  pcall = function(f, ...) return true, f(...) end
end
if options.nocorpora then
  corpora, add_to_corpus = nil, function() end
else
  corpora = options.corpora or corpora
  local missing = { }
  for class in pairs(cfg.classes) do
    if not util.isdir(corpora .. '/' .. class) then
      table.insert(missing, class)
    end
  end
  if #missing > 0 then
    table.sort(missing, util.case_lt)
    util.die("These classes are missing from ", corpora, ": ",
             table.concat(missing, ' '))
  end
end

osbf.init(options)


local msgs, filename = { }, { }
for _, file in ipairs(args) do
  local ok, m = pcall(msg.of_file, file)
  if ok then
    table.insert(msgs, m)
    filename[m] = file
  else io.stderr:write(file, ': ', m, '\n')
  end
end

local trainings = 0

cfg.count_classifications = false

local function openclass(class)
--  io.stderr:write('Trying to open class ', class, '\n')
  return core.open_class(cfg.classes[class].db, 'rwh')
end

local function msgtab(m)
  local train, conf, _, _, class = commands.classify(m)
  return { msg = m, class = class, conf = conf, epoch = trainings, train = train }
end

if msgs[1] then commands.classify(msgs[1]) end -- load cfc files from disk
local start = os.time()
for i = 1, #msgs do
  msgs[i] = msgtab(msgs[i])
end
local class_time = os.difftime(os.time(), start)
local rate = #msgs/class_time
io.stderr:write('Classification rate ', math.floor(rate), ' msgs/s\n')

local chunk_size = math.max(math.floor(rate * .100), 10)
    -- do at least 10 or 100 msec worth
io.stderr:write('Classification chunk size is ', chunk_size, ' msgs\n')

local function conf_lt(t1, t2)
  if t1.train == t2.train then
    return t1.conf < t2.conf
  else
    return t1.train
  end
end

table.sort(msgs, conf_lt)

local get_label, batch_label

function label_next()
  local t = assert(table.remove(msgs, 1))
  local c = openclass(t.class)
  c.classifications = c.classifications + 1
  local class, other = get_label(t, { q = true, d = true, n = true })
  if class then
    add_to_corpus(filename[t.msg], class)
    if t.train or class ~= t.class then
      commands.learn_msg(t.msg, class)
      trainings = trainings + 1
      for i = 1, math.min(#msgs, chunk_size) do
        msgs[i] = msgtab(msgs[i].msg)
      end
      table.sort(msgs, conf_lt)
    end
  elseif other == 'q' then core.close(); os.exit(0) -- should not need close()
  elseif other == 'd' then os.remove(filename[t.msg])
  elseif other == 'n' then -- do nothing
  else assert(false, "This can't happen")
  end
end
    
function label_all()
  while #msgs > 0 do
    for i = 1, math.min(5, #msgs) do
      if msgs[i].train or options.force then
        label_next()
        return label_all()
      else
        for i = 1, #msgs do
          local t = msgs[i]
          if t.epoch < trainings then
            msgs[i] = msgtab(t.msg)
          end
        end
        table.sort(msgs, conf_lt)
        if msgs[1].train then
          label_next()
          return label_all()
        end
      end
    end
    batch_label()
  end
end

-------------------------------
local function printf(...) return io.stdout:write(string.format(...)) end

local function synopsis(m, w)
  local s = msg.header_tagged(m, 'subject') or ''
  s = s .. '>>'
  if string.len(s) < w then
    local body = string.gsub(m.body, '^%s*', '')
    body = string.gsub(body, '%s+', ' ')
    return s .. string.sub(body, 1, w-string.len(s))
  else
    return string.sub(s, 1, w)
  end
end

function batch_label()
  local first, last = 1, math.min(30, #msgs)
  repeat
    for i = first, last do
      local t = msgs[i]
      printf('%-5.5s [%4.1f]: %s\n', t.class, t.conf, synopsis(t.msg, 60))
    end
    first, last = last+1, math.min(last+31, #msgs)
    io.stderr:write('Batch labelling not implemented; hit enter or q\n')
    local what = io.stdin:read()
  until what == 'q' or first > #msgs
  -- do return label_next() end
  core.close() -- should not be needed
  os.exit(0)
end


-------------------------------------------------------------------------------
-- from here down should be replaced with something more generic

dofile(os.getenv('HOME') .. '/.lmrc')

require 'nrmime'

local M = Luamail
local P = M.preferences()
local Parser = MIME.Parser

require 'signal'
signal.ignore(signal.PIPE);

local classlist = table.concat(cfg.classlist(), ' ')

function get_label(t, special)
  local file = filename[t.msg]
  local e = Parser:parse_open(file)
  if e then
    os.execute('reset')
    local outfile = io.popen('less -i -X -e', 'w')
    M.run.show(outfile, e)
    outfile:close()
    local function subst(s)
      if s == t.class then
        return string.upper(s) .. string.format(' [%.1f]', t.conf)
      else
        return s
      end
    end
    local options = string.gsub(classlist, '%S+', subst)
    local class
    repeat
      io.stdout:write('Class [', options, ']? ')
      io.stdout:flush()
      class = io.read()
    until cfg.classes[class] or special[class] or class == ''
    if class == '' then return t.class
    elseif special[class] then return nil, class
    else return class
    end
  end
end

----------------------------------------------------------------

label_all()
