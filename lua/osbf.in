#! @LUA@
--[[
OSBF: 
  train even if a message not in the cache -- insert on training! (for testing)
  regression test accuracy on trec 2005 and trec 2006 ('full') and
  also 'fast'
]]

-- simple command-line client



require '@MOD_NAME@'
require '@MOD_NAME@.command_line'
require '@MOD_NAME@.options'
require '@MOD_NAME@.util'
require '@MOD_NAME@.output'

@MOD_NAME@.util.progname = arg[0] or '@MOD_NAME@'

local function die(...)
  io.stderr:write(...)
  os.exit(1)
end

@MOD_NAME@.options.register { long = 'trace', usage = ' # stack trace on error',
                   help = [[
  --trace
      Don't recover from errors; give a stack trace instead
]] }

@MOD_NAME@.options.register { long = 'profile', usage = ' # profile to @MOD_NAME@.lprof',
                   help = [[
  --profile
      Write a LuaProfiler profile to lprof.out
]] }

local ok, options, args = pcall(@MOD_NAME@.options.parse, arg)
if not ok then
  die(arg[0], ': ', options, '\n')
end

if options.profile then
  require 'profiler'
  profiler.start '@MOD_NAME@.lprof'
end

-- we dare not override the global pcall, because that's used
-- as an exception handler for trying to parse subject-line commands
if options.trace then
  @MOD_NAME@.command_line.pcall = function(f, ...) return true, f(...) end
end

local pcall = @MOD_NAME@.command_line.pcall

local ok, msg = pcall(@MOD_NAME@.init, options, args[1] == 'init')
if not ok then
  die(arg[0], ' failed during initialization: ', msg, '\n')
end

@MOD_NAME@.command_line.run(unpack(args))
if options.profile then
  profiler.stop()
end
@MOD_NAME@.output.exit(0)

